diff --git a/code/source_f90/coulex.cu b/code/source_f90/coulex.cu
index 84df18c..fc69db7 100644
--- a/code/source_f90/coulex.cu
+++ b/code/source_f90/coulex.cu
@@ -5,32 +5,25 @@ unsigned int kxmax,kymax,kzmax,ksmax;
 unsigned int kdfull;
 unsigned int kdred;
 unsigned int kfft2;
-//INTEGER,PARAMETER,PRIVATE :: kddoub=kdfull
 unsigned int kfft,kfftx,kffty,kfftz;
-//INTEGER,PARAMETER,PRIVATE :: coulsolv_mp_kdcorf_=(kxmax/2+1)*(kymax/2+1)*(kzmax/2+1);
-// include block: xkgrid
-//extern double coulsolv_mp_xval_[],coulsolv_mp_yval_[],coulsolv_mp_zval_[];
-//extern double coulsolv_mp_xt2_[],coulsolv_mp_yt2_[],coulsolv_mp_zt2_[];
 double dx,dy,dz,dxsp,grnorm,fnorm,tnorm;
 unsigned int nxc,nyc,nzc,nx1,ny1,nz1;
-//unsigned int nxr,nxi,nyr,nyi,nzr,nzi;
 unsigned int nxi,nyi,nzi;
 unsigned int nxy1,nxyz,nxhigh;
 unsigned int nxlow,nyhigh,nylow,nzhigh,nzlow;
 
-//extern int coulsolv_mp_ikm_[][];
 double dkx,dky,dkz,akmax,dksp,ecut;
 unsigned int nxk,nxklo,nxkhi,nksp,nkxyz;
 
 double zero=0.0;
 double pi=3.141592653589793;
 
-
-//double *akv2r,*akv2i,*pakv2r,*pakv2i;
-cufftHandle pfft;
+cufftHandle pfftforw,pfftback;
 int batch=1;
-cufftDoubleComplex *fftac,*akvc,*pfftac,*pakvc;
+cufftDoubleReal *rfftac,*akvr,*prfftac,*pakvr;
 cufftDoubleComplex *gpu_fftac,*gpu_akvc;
+cufftDoubleReal *gpu_rfftac,*gpu_akvr;
+
 int res;
 
 //-----fourfakv---------------------------------------------------------
@@ -53,10 +46,10 @@ dim3 dimblock(blocksize,1,1);
 
 tnorm=grnorm*fnorm;
 
-cudaMemcpyAsync(gpu_akvc,pakvc,kdred*sizeof(cufftDoubleComplex),cudaMemcpyHostToDevice,stream1);
+cudaMemcpyAsync(gpu_akvr,pakvr,kdred*sizeof(cufftDoubleReal),cudaMemcpyHostToDevice,stream1);
 Check_CUDA_Error(error);
 
-if(cufftExecZ2Z(pfft,gpu_akvc,gpu_akvc, CUFFT_FORWARD) != CUFFT_SUCCESS)
+if(cufftExecD2Z(pfftforw,gpu_akvr,gpu_akvc) != CUFFT_SUCCESS)
 {
   cout<<"CUFFT error : Exec Z2Z forward failed in coulex (akv)"<<endl;
   exit(-1);
@@ -153,14 +146,13 @@ for (int i3=1;i3<=nzi;i3++){
 //        cout<< " i1,i2,i3,ii= "<<i1<<" "<<i2<<" "<<i3<<" "ii;
       ind=((i3+nxc)%nxi)*nxyfn+((i2+nyc)%nyi)*kfftx+(i1+nyc)%nzi+1; //storage in a flatten 3D complex array for FFT on GPU
       if(ii != ikzero) {
-        akvc[ind].x =  1.0/sqrt(ak2);
+        akvr[ind] =  1.0/sqrt(ak2);
       }
       else {
 //              akv2r(ii) = (6D0*pi/(dx*dy*dz))**(1D0/3D0)  // spherical approx
 //              akv2r(ii) = 1.19003868*(dx*dy*dz)**(-1D0/3D0)
-        akvc[ind].x = 2.34*1.19003868*pow((dx*dy*dz),(-1.0/3.0));  // empirical
+        akvr[ind] = 2.34*1.19003868*pow((dx*dy*dz),(-1.0/3.0));  // empirical
       }
-      akvc[ind].y = 0.0;
     }
   }
 }
@@ -168,7 +160,8 @@ nksp=ii;
 
 fourfakv();
 
-cudaFreeHost(pakvc);
+cudaFreeHost(pakvr);
+cudaFree(gpu_akvr);
 
 }
 
@@ -196,28 +189,39 @@ kfft2=kfft*2;
 
 //     check initialization
 
-if(cufftPlan3d(&pfft,kxmax,kymax,kzmax,CUFFT_Z2Z) != CUFFT_SUCCESS)
+if(cufftPlan3d(&pfftforw,kxmax,kymax,kzmax,CUFFT_D2Z) != CUFFT_SUCCESS)
 {
   cout<<"CUFFT error : Plan Creation failed"<<endl;
   exit(-1);
 }
-if(cufftSetStream(pfft,stream2) != CUFFT_SUCCESS)
+if(cufftSetStream(pfftforw,stream2) != CUFFT_SUCCESS)
+{
+  cout<<"CUFFT error : Streamed FFT Creation failed"<<endl;
+  exit(-1);
+}
+if(cufftPlan3d(&pfftback,kxmax,kymax,kzmax,CUFFT_Z2D) != CUFFT_SUCCESS)
+{
+  cout<<"CUFFT error : Plan Creation failed"<<endl;
+  exit(-1);
+}
+if(cufftSetStream(pfftback,stream2) != CUFFT_SUCCESS)
 {
   cout<<"CUFFT error : Streamed FFT Creation failed"<<endl;
   exit(-1);
 }
-
 // Pinned memory allocation on the CPU to make CPU>GPU and GPU>CPU transfers faster
 
-cudaMallocHost (&pfftac,kdred*sizeof(cufftDoubleComplex));
-cudaMallocHost (&pakvc,kdred*sizeof(cufftDoubleComplex));
+cudaMallocHost (&prfftac,kdred*sizeof(cufftDoubleReal));
+cudaMallocHost (&pakvr,kdred*sizeof(cufftDoubleReal));
 
-fftac=pfftac-1; //fftac points one location before pfftac, so fftac[1]...fftac[kdred] all exist (just sticks with the fortran convention)
-akvc=pakvc-1;   //same trick as above
+rfftac=prfftac-1; //rfftac points one location before prfftac, so rfftac[1]...rfftac[kdred] all exist (just sticks with the fortran convention)
+akvr=pakvr-1;   //same trick as above
 
 // Memory allocation on the GPU
 cudaMalloc((void**)&gpu_fftac,kdred*sizeof(cufftDoubleComplex));
 cudaMalloc((void**)&gpu_akvc,kdred*sizeof(cufftDoubleComplex));
+cudaMalloc((void**)&gpu_rfftac,kdred*sizeof(cufftDoubleReal));
+cudaMalloc((void**)&gpu_akvr,kdred*sizeof(cufftDoubleReal));
 
 //     call input routine fftinp, which initializes the grid and fft tabl
 
@@ -235,10 +239,10 @@ dim3 dimblock(blocksize,1,1);
 
 tnorm=grnorm*fnorm;
 
-cudaMemcpyAsync(gpu_fftac,pfftac,kdred*sizeof(cufftDoubleComplex),cudaMemcpyHostToDevice,stream1);
+cudaMemcpyAsync(gpu_rfftac,prfftac,kdred*sizeof(cufftDoubleReal),cudaMemcpyHostToDevice,stream1);
 Check_CUDA_Error(error);
 
-if(cufftExecZ2Z(pfft,gpu_fftac,gpu_fftac, CUFFT_FORWARD) != CUFFT_SUCCESS)
+if(cufftExecD2Z(pfftforw,gpu_rfftac,gpu_fftac) != CUFFT_SUCCESS)
 {
   cout<<"CUFFT error : Exec Z2Z forward failed in coulex"<<endl;
   exit(-1);
@@ -262,16 +266,16 @@ dim3 dimblock(blocksize,1,1);
 
 tnorm=fnorm/(8.0*grnorm)*pow(pi,1.5);
 
-if(cufftExecZ2Z(pfft,gpu_fftac,gpu_fftac, CUFFT_INVERSE) != CUFFT_SUCCESS)
+if(cufftExecZ2D(pfftback,gpu_fftac,gpu_rfftac) != CUFFT_SUCCESS)
 {
 	  cout<<"CUFFT error : Exec Z2Z backward failed in coulex"<<endl;
 	  exit(-1);
 }
 
-multiply_device<<<dimgrid,dimblock,0,stream2>>>(gpu_fftac,kdred,tnorm);
+multiply_device_real<<<dimgrid,dimblock,0,stream2>>>(gpu_rfftac,kdred,tnorm);
 Check_CUDA_Error(error);
 
-cudaMemcpy(pfftac,gpu_fftac,kdred*sizeof(cufftDoubleComplex),cudaMemcpyDeviceToHost);
+cudaMemcpy(prfftac,gpu_rfftac,kdred*sizeof(cufftDoubleReal),cudaMemcpyDeviceToHost);
 Check_CUDA_Error(error);
 
 }
@@ -323,10 +327,9 @@ for (int i3=1;i3<=kfftz;i3++){
       ii=((i3+nxc)%nnx2)*nxyfn+((i2+nyc)%nny2)*nyfn+(i1+nzc)%nnz2+1;
       if(i3 <= nzc && i2 <= nyc && i1 <= nxc) {
         i0 = i0+1;
-        fftac[ii].x=rhoinp[i0];
+        rfftac[ii]=rhoinp[i0];
       }
-      else fftac[ii].x=0.0;
-      fftac[ii].y=0.0;
+      else rfftac[ii]=0.0;
     }
   }
 }
@@ -354,7 +357,7 @@ for (int i3=1;i3<=nzc;i3++){
     for (int i1=1;i1<=nxc;i1++){
         i0++;
         ii=((i3+nxc)%nnx2)*nxyfn+((i2+nyc)%nny2)*nyfn+(i1+nzc)%nnz2+1;
-        chpfalr[i0] = 2.0*fftac[ii].x;
+        chpfalr[i0] = 2.0*rfftac[ii];
     }
   }
 }
@@ -384,14 +387,15 @@ coufou2();
 //     and maybe some other things to an output file or the screen.
 
 result(chpfalr);
-
 }
 
 extern "C" void coulsolv_end_() {
 
-cudaFreeHost(pfftac);
+cudaFreeHost(prfftac);
 cudaFree(gpu_fftac);
+cudaFree(gpu_rfftac);
 cudaFree(gpu_akvc);
-cufftDestroy(pfft);
+cufftDestroy(pfftforw);
+cufftDestroy(pfftback);
 
 }
diff --git a/code/source_f90/cuda.cu b/code/source_f90/cuda.cu
index 43dd2b7..adb6395 100644
--- a/code/source_f90/cuda.cu
+++ b/code/source_f90/cuda.cu
@@ -122,6 +122,38 @@ extern "C" void cuda_plan_3d_(cufftHandle *plan, int *n1, int *n2, int *n3)
 	}
 }
 
+extern "C" void cuda_plan_3d_r2c_(cufftHandle *plan, int *n1, int *n2, int *n3)
+{
+	//Creation of a 3D FFT plan for GPU (the plan is the same for FORWARD and BACKWARD FFT)
+        if(cufftPlan3d(plan,*n3,*n2,*n1,CUFFT_D2Z) != CUFFT_SUCCESS)
+	{
+	  cout<<"CUFFT error : Plan Creation failed"<<endl;
+	  exit(-1);
+	}
+	//Associate the plan to a stream
+        if(cufftSetStream(*plan,stream2) != CUFFT_SUCCESS)
+	{
+	  cout<<"CUFFT error : Streamed FFT Creation failed"<<endl;
+	  exit(-1);
+	}
+}
+
+extern "C" void cuda_plan_3d_c2r_(cufftHandle *plan, int *n1, int *n2, int *n3)
+{
+	//Creation of a 3D FFT plan for GPU (the plan is the same for FORWARD and BACKWARD FFT)
+        if(cufftPlan3d(plan,*n3,*n2,*n1,CUFFT_Z2D) != CUFFT_SUCCESS)
+	{
+	  cout<<"CUFFT error : Plan Creation failed"<<endl;
+	  exit(-1);
+	}
+	//Associate the plan to a stream
+        if(cufftSetStream(*plan,stream2) != CUFFT_SUCCESS)
+	{
+	  cout<<"CUFFT error : Streamed FFT Creation failed"<<endl;
+	  exit(-1);
+	}
+}
+
 extern "C" void kill_plan_(cufftHandle *plan)
 {
 	//Destroy FFT plan
diff --git a/code/source_f90/gpu_compute.cu b/code/source_f90/gpu_compute.cu
index 43f974f..6ba3297 100644
--- a/code/source_f90/gpu_compute.cu
+++ b/code/source_f90/gpu_compute.cu
@@ -11,6 +11,16 @@ __global__ void multiply_device(cufftDoubleComplex *d_ffta,int nxyz,double norm)
 	}
 }
 
+__global__ void multiply_device_real(cufftDoubleReal *d_ffta,int nxyz,double norm)
+{
+	unsigned int ind = blockIdx.x*blockDim.x+threadIdx.x;
+
+	if (ind<nxyz)
+	{
+		d_ffta[ind]=norm*d_ffta[ind];
+	}
+}
+
 extern "C" void multiply_gpu_(cufftDoubleComplex *d_ffta,int *N,double *tnorm)
 {
 	int nxyz = *N;
