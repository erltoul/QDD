Run configure script to regenerate a makefile that will produced the required binary.

./configure
Default, compile with netlib fftpack, sequential. The executable is called bin/netlib_pwteleman.seq.

./configure --with-para --with-compiler=mpifort
Compile with netlib fftpack, parallel (number of processors givent at runtime).
The executable is called bin/netlib_pwteleman.par
Instead of mpifort, one can use an other MPI wrappers, like mpif90, but in any case it has to be configured with ifort.
One can also directly use ifort, but location of openmpi libraries must then be specfied using environment variable CPPFLAGS and LDFLAGS.

./configure --with-fft=FFTW 
Compile with FFTW functions (need FFTW 3.3.2 or later), sequential. 
The executable is called bin/fftw_pwteleman.seq

./configure --with-fft=FFTW --with-para --with-compiler=mpifort
A simple combination of previous examples. 
Compile with FFTW functions (need FFTW 3.3.2), parallel (with number of processor given at runtime.)
The executable is called bin/fftw_pwteleman.par

./configure --with-fft=CUFFT
Compile with cuda functions, sequential. 
The executable is called bin/gpu_pwteleman.seq

./configure --with-fft=CUFFT  --with-para --with-compiler=mpifort
A combination of previous examples. 
Compile with cuda functions. The number of GPUs is dependant on the number of GPUs in the computation node. 
The best configuration is one MPI process for 1 GPU.
The executable is called bin/gpu_pwteleman.par



Some word on wisdom (from the FFTW manual):

"FFTW implements a method for saving plans to disk and restoring them. In fact, what
FFTW does is more general than just saving and loading plans. The mechanism is called
wisdom. [...]
Plans created with the FFTW_MEASURE, FFTW_PATIENT, or FFTW_EXHAUSTIVE options produce
near-optimal FFT performance, but may require a long time to compute because FFTW
must measure the runtime of many possible plans and select the best one. This setup is
designed for the situations where so many transforms of the same size must be computed
that the start-up time is irrelevant. For short initialization times, but slower transforms,
we have provided FFTW_ESTIMATE. The wisdom mechanism is a way to get the best of both
worlds: you compute a good plan once, save it to disk, and later reload it as many times as
necessary. The wisdom mechanism can actually save and reload many plans at once, not
just one.
Whenever you create a plan, the FFTW planner accumulates wisdom, which is information
sufficient to reconstruct the plan. After planning, you can save this information to disk
[...]
The next time you run the program, you can restore the wisdom and then recreate the plan using
the same flags as before.
Wisdom is automatically used for any size to which it is applicable, as long as the planner
flags are not more "patient" than those with which the wisdom was created. For example,
wisdom created with FFTW_MEASURE can be used if you later plan with FFTW_ESTIMATE or
FFTW_MEASURE, but not with FFTW_PATIENT."

In the code, FFTW_EXHAUSTIVE is used, and wisdom is stored in wisdom_fftw.dat file.
The first time the code is launched with FFTW activated, it will warn you that wisdom_fftw.dat does not exist and it will create it.
So for each new FFT grid size, the program will compute a good plan (it could take a long time), and then it will re-use it every time the program is launched with such grid size. A wisdom file can be exported from one computer to another, but the optimal way to do FFT is depending of the architecture.
