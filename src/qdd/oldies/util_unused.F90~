!-----projmoms-------------------------------------------------------projmoms
! REAL version
!-----------------------------------------------------------------------
SUBROUTINE r_projmoms(rho,psi)

! Multipole moments relative to c.m. and relative to ion coordinate 'cz'.
! ??? presently not used ???

USE params
IMPLICIT NONE

REAL(DP), INTENT(IN) :: rho(2*kdfull2)
REAL(DP), INTENT(IN) :: psi(kdfull2,kstate)
#if(parayes)
INCLUDE 'mpif.h'
INTEGER :: is(mpi_status_size)
#endif

INTEGER :: ind, ix, iy, iz, k
REAL(DP) :: sproj,starget
REAL(DP) :: x1, y1, z1, x1t, y1t, z1t, x1p, y1p, z1p 

#if(parano)
INTEGER :: ik, ikk
#else
INTEGER :: kk,nbe,nbee
REAL(DP) :: sprojec
#endif
!----------------------------------------------------------------------
nrmom=35
IF(nrmom > kmom) STOP ' too many moments in projmoms'

DO k=1,nrmom
  qetarget(k)=0D0
  qeproj(k)=0D0
END DO

!     switch for calculating moments relative to center of mass (1)
!     or center of box (0)
rvectmp = 0D0
IF(iemomsrel == 1 .AND. nion2 > 0) CALL getcm(1,0,0)


ind=0
DO iz=minz,maxz
  z1=(iz-nzsh)*dz
  z1t=z1-rvectmp(3)
  z1p=z1-cz(nproj)
  DO iy=miny,maxy
    y1=(iy-nysh)*dy
    y1t=y1-rvectmp(2)
    y1p=y1-cy(nproj)
    DO ix=minx,maxx
      ind=ind+1
      IF((ix <= nx2).AND.(iy <= ny2).AND.(iz <= nz2)) THEN
        x1=(ix-nxsh)*dx
        x1t=x1-rvectmp(1)
        x1p=x1-cx(nproj)
        sproj=0D0
#if(parano)
        DO ik=1,nproj_states
          ikk=proj_states(ik)
          sproj=sproj+psi(ind,ikk)*psi(ind,ikk) 
        END DO
#else
        sprojec=0D0 
        DO nbe=1,nstate
          nbee=nrel2abs(nbe)
          DO kk=1,nproj_states
            IF (nbee == proj_states(kk)) THEN
              sprojec=sprojec+psi(ind,nbe)*psi(ind,nbe) 
            END IF
          END DO
        END DO
        CALL mpi_barrier(mpi_comm_world, mpi_ierror)
        CALL mpi_allreduce(sprojec,sproj,1,mpi_double_precision,  &
                mpi_sum,mpi_comm_world,mpi_ierror)
        CALL mpi_barrier(mpi_comm_world, mpi_ierror)
#endif
        starget=rho(ind)-sproj
!                                                     monopole
        qetarget(1)=qetarget(1)+starget
        qeproj(1)=qeproj(1)+sproj
!                                                     dipole
        qetarget(2)=qetarget(2)+starget*x1t
        qetarget(3)=qetarget(3)+starget*y1t
        qetarget(4)=qetarget(4)+starget*z1t

        qeproj(2)=qeproj(2)+sproj*x1p
        qeproj(3)=qeproj(3)+sproj*y1p
        qeproj(4)=qeproj(4)+sproj*z1p
      END IF
    END DO
  END DO
END DO

DO k=1,nrmom
  qetarget(k)=qetarget(k)*dvol
  qeproj(k)=qeproj(k)*dvol
END DO

DO k=2,nrmom
  qetarget(k)=qetarget(k)/qetarget(1)      !normalization
  qeproj(k)=qeproj(k)/qeproj(1)      !normalization
END DO

RETURN
END SUBROUTINE r_projmoms

!-----------------------------------------------------------------------
! COMPLEX version
!-----------------------------------------------------------------------
SUBROUTINE c_projmoms(rho,psi)
USE params
IMPLICIT NONE

REAL(DP), INTENT(IN)    :: rho(2*kdfull2)
COMPLEX(DP), INTENT(IN) :: psi(kdfull2,kstate)
#if(parayes)
INCLUDE 'mpif.h'
INTEGER :: is(mpi_status_size)
#endif

INTEGER :: ind, ix, iy, iz, k
REAL(DP) :: sproj,starget
REAL(DP) :: x1, y1, z1, x1t, y1t, z1t, x1p, y1p, z1p 

#if(parano)
INTEGER :: ik, ikk
#else
INTEGER :: kk, nbe, nbee
REAL(DP) :: sprojec
#endif
!----------------------------------------------------------------------
nrmom=35
IF(nrmom > kmom) STOP ' too many moments in projmoms'

DO k=1,nrmom
  qetarget(k)=0D0
  qeproj(k)=0D0
END DO

!     switch for calculating moments relative to center of mass (1)
!     or center of box (0)
rvectmp = 0D0
IF(iemomsrel == 1 .AND. nion2 > 0) CALL getcm(1,0,0)

ind=0
DO iz=minz,maxz
  z1=(iz-nzsh)*dz
  z1t=z1-rvectmp(3)
  z1p=z1-cz(nproj)
  DO iy=miny,maxy
    y1=(iy-nysh)*dy
    y1t=y1-rvectmp(2)
    y1p=y1-cy(nproj)
    DO ix=minx,maxx
      ind=ind+1
      IF((ix <= nx2).AND.(iy <= ny2).AND.(iz <= nz2)) THEN
        x1=(ix-nxsh)*dx
        x1t=x1-rvectmp(1)
        x1p=x1-cx(nproj)
        sproj=0D0
#if(parano)
        DO ik=1,nproj_states
          ikk=proj_states(ik)
          sproj=sproj+REAL(CONJG(psi(ind,ikk))*psi(ind,ikk),DP)
        END DO
#else
        sprojec=0D0 
        DO nbe=1,nstate
          nbee=nrel2abs(nbe)
          DO kk=1,nproj_states
            IF (nbee == proj_states(kk)) THEN
              sprojec=sprojec+REAL(CONJG(psi(ind,nbe))*psi(ind,nbe),DP)
            END IF
          END DO
        END DO
        CALL mpi_barrier(mpi_comm_world, mpi_ierror)
        CALL mpi_allreduce(sprojec,sproj,1,mpi_double_precision,  &
          mpi_sum,mpi_comm_world,mpi_ierror)
        CALL mpi_barrier(mpi_comm_world, mpi_ierror)
#endif
        starget=rho(ind)-sproj
!                                                     monopole
        qetarget(1)=qetarget(1)+starget
        qeproj(1)=qeproj(1)+sproj
!                                                     dipole
        qetarget(2)=qetarget(2)+starget*x1t
        qetarget(3)=qetarget(3)+starget*y1t
        qetarget(4)=qetarget(4)+starget*z1t

        qeproj(2)=qeproj(2)+sproj*x1p
        qeproj(3)=qeproj(3)+sproj*y1p
        qeproj(4)=qeproj(4)+sproj*z1p
      END IF
    END DO
  END DO
END DO

DO k=1,nrmom
  qetarget(k)=qetarget(k)*dvol
  qeproj(k)=qeproj(k)*dvol
END DO

DO k=2,nrmom
  qetarget(k)=qetarget(k)/qetarget(1)      !normalization
  qeproj(k)=qeproj(k)/qeproj(1)      !normalization
END DO

RETURN
END SUBROUTINE c_projmoms



